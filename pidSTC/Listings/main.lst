C51 COMPILER V9.00   MAIN                                                                  05/19/2016 16:51:06 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /*
   2              
   3            1500850226 杨宇庆 版权所有
   4                        
   5                        2015年12月24日
   6          */
   7          #include <STC12C5A60S2.H>
   8          #include "delay.h"
   9          
  10          #include "uart.h"
  11          
  12          #include "pid.h"
  13          
  14          sbit shu_dat=P0^0;
  15          sbit shu_g=P0^1;
  16          sbit shu_rck=P0^2;
  17          sbit shu_sck=P0^3;
  18          
  19          sbit spk=P1^3;
  20          
  21          sbit fan=P1^6;
  22          
  23          sbit key1=P2^7;
  24          sbit key2=P2^6;
  25          sbit key3=P2^5;
  26          sbit key4=P2^4;
  27          
  28          sbit Pex1=P3^3;
  29          
  30          code unsigned char shu[]={0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f};
  31          
  32          void SendDataShu(unsigned int dat);
  33          
  34          void key_scan();
  35          void SPK_Err();
  36          void SPK_Info();
  37          
  38          unsigned int speed_t=0;
  39          
  40          unsigned char mode=0;
  41          
  42          unsigned char PWM_CUR=0,PWM_DES=50;
  43          
  44          unsigned char Press=0;
  45          
  46          bit scan=0;
  47          bit flag_1s,flag_10ms;
  48          bit speaking=0;
  49          bit start=0;
  50          int PWM,Speed_Measure;
  51          
  52          PID_Uint sPID,*sptr= &sPID;
  53          
  54          void SPK_Info()
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 16:51:06 PAGE 2   

  55          {
  56   1        spk=1;
  57   1      }
  58          void SendDataShu(unsigned int dat)
  59          {
  60   1        unsigned char i=0,j=0,num[4]={0};
  61   1      
  62   1        num[0]=shu[dat/1000];
  63   1        num[1]=shu[dat%1000/100];
  64   1        num[2]=shu[dat%1000%100/10];
  65   1        num[3]=shu[dat%1000%100%10];
  66   1        for(i=0;i<3;i++)
  67   1        {
  68   2          if(num[i]!=shu[0])
  69   2            break;
  70   2          num[i]=0;
  71   2        }
  72   1        
  73   1      //  if(mode==1)
  74   1      //    num[0]=0x73;
  75   1        
  76   1        for(j=0;j<4;j++)
  77   1        {
  78   2          P0=(P0&0x0F)|(0x10<<j);
  79   2          for(i=0;i<8;i++)
  80   2          {
  81   3            shu_dat=num[j]&0x80;
  82   3            shu_sck=0;
  83   3            shu_sck=1;
  84   3            num[j]<<=1;
  85   3          }
  86   2          shu_rck=0;
  87   2          shu_rck=1;
  88   2          Delay50us();
  89   2      
  90   2          shu_dat=0;
  91   2          for(i=0;i<8;i++)
  92   2          {
  93   3            shu_sck=0;
  94   3            shu_sck=1;
  95   3          }   
  96   2          shu_rck=0;
  97   2          shu_rck=1;
  98   2        }
  99   1        
 100   1      }
 101          
 102          void Timer0Init(void)   //1毫秒@11.0592MHz
 103          {
 104   1        AUXR |= 0x80;   //定时器时钟1T模式
 105   1        TMOD &= 0xF0;   //设置定时器模式
 106   1        TL0 = 0xCD;   //设置定时初值
 107   1        TH0 = 0xD4;   //设置定时初值
 108   1        TF0 = 0;    //清除TF0标志
 109   1        TR0 = 1;    //定时器0开始计时
 110   1      }
 111          void Ex0() interrupt 0
 112          {
 113   1        speed_t++;
 114   1      }
 115          void timer0_isr() interrupt 1
 116          {
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 16:51:06 PAGE 3   

 117   1        static unsigned int counter_1s,counter_10ms;
 118   1        if(++counter_1s>=1000)        
 119   1        {
 120   2          counter_1s=0;
 121   2          flag_1s=1;
 122   2          
 123   2          Speed_Measure=speed_t;   ////计算速度
 124   2          speed_t=0;
 125   2          
 126   2          UartSendSpeed(Speed_Measure);
 127   2          UartSendPWM(PWM_DES);
 128   2          
 129   2        }
 130   1        if(++counter_10ms>=10)
 131   1        {
 132   2          flag_10ms=1;
 133   2          counter_10ms=0;
 134   2        }
 135   1        
 136   1        PWM_CUR++;
 137   1        if (PWM_CUR < PWM_DES)
 138   1          fan = 1; 
 139   1        if(PWM_CUR >=PWM_DES)
 140   1          fan = 0;      
 141   1        
 142   1        if(PWM_CUR>100)
 143   1          PWM_CUR=0;
 144   1      
 145   1      }
 146          /*
 147          void key_scan()
 148          {
 149            if(!key1)
 150            {
 151              Delay1ms();
 152              if(!key1)
 153              {
 154                if(mode==1)
 155                  mode=0;
 156                else
 157                  mode=1;
 158                while(!key1);
 159              }
 160            }else if(!key2)
 161            {
 162              Delay1ms();
 163              if(!key2)
 164              {
 165                if(mode==1)
 166                {
 167                  if(PWM_DES>=10)
 168                  {
 169                    PWM_DES-=10;
 170                    
 171                  }
 172                }else if(mode==2)
 173                {
 174                  if(speed_des>0)
 175                    speed_des-=200;
 176                  
 177                }
 178                while(!key2);
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 16:51:06 PAGE 4   

 179              }
 180            }else if(!key3)
 181            {
 182              Delay1ms();
 183              if(!key3)
 184              {
 185                if(mode==1)
 186                {
 187                  if(PWM_DES<=90)
 188                  {
 189                    PWM_DES+=10;
 190                    
 191                  }
 192                }else if(mode==2)
 193                {
 194                  if(speed_des<3000)
 195                    speed_des+=200;
 196                  
 197                }
 198                while(!key3);
 199              }
 200            }else if(!key4)
 201            {
 202              Delay1ms();
 203              if(!key4)
 204              {
 205                
 206                if(mode==2)
 207                {       
 208                  lock=0;
 209                  mode=0;
 210                }
 211                  else
 212                {
 213                  lock=1;
 214                  mode=2;
 215                }
 216                
 217                while(!key4);
 218              }
 219            }
 220          }
 221          */
 222          
 223          void init()
 224          {
 225   1        Speed_Measure=0;
 226   1      
 227   1        PIDInit(sptr);
 228   1        
 229   1        P0M0=0xF0;
 230   1        P1M0|=0x88;
 231   1        shu_g=0;
 232   1        Timer0Init();
 233   1        UartInit();
 234   1        
 235   1        spk=0;
 236   1        
 237   1        fan=0;
 238   1        
 239   1        IT0=1;//下降沿触发
 240   1        EX0=1;//外部中断0开
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 16:51:06 PAGE 5   

 241   1        
 242   1        ET0=1;
 243   1        
 244   1        ET0=1;EX0=1;
 245   1        
 246   1        EA=1;
 247   1        
 248   1        P2=0xFF;
 249   1      }
 250          
 251          int main()
 252          {
 253   1        int PWM_PID;
 254   1        
 255   1        init();
 256   1        
 257   1        while(1)
 258   1        {
 259   2      //    if(mode==0)
 260   2      //      SendDataShu(speed);
 261   2      //    else if(mode==2)
 262   2      //      SendDataShu(PWM_DES);
 263   2          
 264   2          if(flag_10ms)
 265   2          {
 266   3            flag_10ms=0;
 267   3            
 268   3          }
 269   2          
 270   2          if(flag_1s)
 271   2          {
 272   3            flag_1s=0;
 273   3            
 274   3            spk=0;
 275   3            
 276   3            //if(start)
 277   3            {
 278   4              
 279   4            }
 280   3            
 281   3            //UartSendByte(Speed_Measure);
 282   3            if(mode==0)
 283   3            {
 284   4              PWM_PID=PID_Calc(Speed_Measure,sptr);
 285   4              if((PWM_DES+0.5*PWM_PID)<100&&(PWM_DES+0.5*PWM_PID)>0) //防止调节比例过大 造成PWM值超出范围
 286   4              {
 287   5                if(mode==0)
 288   5                  PWM_DES=PWM_DES+0.5*PWM_PID;//0.5用于保证速度调整跨度过大时PWM不会过界
 289   5              }
 290   4            }else if(mode==1)
 291   3            {
 292   4              
 293   4            }
 294   3          }
 295   2          SendDataShu(Speed_Measure);
 296   2          //key_scan();
 297   2        }
 298   1        return 0;
 299   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 16:51:06 PAGE 6   

   CODE SIZE        =    865    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =     35       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
